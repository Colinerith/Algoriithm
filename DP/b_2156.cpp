/*
포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고,
마신 후에는 원래 위치에 다시 놓아야 한다.
연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

첫째 줄에 포도주 잔의 개수 n이 주어진다.
(1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다.
포도주의 양은 1,000 이하의 음이 아닌 정수이다.

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.
*/

#include<iostream>
using namespace std;
#define max(a, b) ((a > b) ? a : b) //끝에 세미콜론 붙이면 안 됨

int d[10000][3]; //0:지금 잔 안 마심, 1:지금 잔이 연속 한잔째, 2:지금 잔이 연속 두잔째
int a[10000];

int main() {
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	d[0][0] = 0; d[0][1] = a[0]; d[0][2] = 0;// 첫 번째 잔이 연속 두 번째 잔일 경우는 없음
	for (int i = 1; i < n; i++) {
		d[i][0] = max(d[i - 1][0], max(d[i - 1][1], d[i - 1][2]));
		d[i][1] = d[i - 1][0] + a[i]; //지금 잔이 연속 한 번째이려면 그 전 잔은 마시지 않았어야 함
		d[i][2] = d[i - 1][1] + a[i]; //지금 잔이 연속 두 번째이려면 그 전 잔을 마셨어야 함
	}
	cout << max(d[n - 1][0], max(d[n - 1][1], d[n - 1][2]));
}
